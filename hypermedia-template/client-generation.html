<!doctype html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Client Generation</title>
    <link rel="stylesheet" href="/HypermediaDocs/lib/bootstrap/dist/css/bootstrap-darkly.css?linkver=20210601023522" type="text/css">

</head>

<body>

    <nav class="navbar navbar-dark bg-dark" data-hr-run="edity.theme.layouts.default">
        <button class="navbar-toggler" type="button" data-target="#sidebar" data-toggle="sidebar" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <a class="navbar-brand" href="/HypermediaDocs/">Threax Hypermedia Framework and Architecture</a>
    </nav>

    <div id="wrapper">
        <!-- Sidebar -->
        <div id="sidebar">
            <div class="mainTreeMenu" data-hr-controller="treeMenu" data-hr-config-urlroot="/HypermediaDocs/" data-hr-config-menu="/HypermediaDocs/menus/mainMenu.json" data-hr-config-scrollelement="#sidebar-wrapper" data-hr-model-component="sidebarMenuComponent" data-hr-config-treemenu-version="4FA66F9D126AFC07B702ED478BF9E1CF73F7A245F99AFFE918467C157FEB3905">
                <ul class="sidebarMenu" data-hr-model="childItems" data-hr-model-component="sidebarMenuComponent">
                    <template data-hr-component="sidebarMenuComponent">
                        <li class="folder">
                            <div class="item" data-hr-on-click="toggleMenuItem" data-hr-toggle="current" data-hr-class-on="currentFolder"><span data-hr-toggle="children" class="glyphicon" data-hr-class-on="glyphicon-folder-open" data-hr-class-off="glyphicon-folder-close"></span> {{name}}</div>
                            <div class="children" data-hr-model="children" data-hr-model-component="sidebarMenuComponent" data-hr-toggle="children" data-hr-class-on="expanded" data-hr-style-off="display:none;"></div>
                        </li>
                    </template>
                    <template data-hr-variant="link">
                        <li class="link">
                            <a href="{{urlRoot}}{{link}}" target="{{target}}">
                                <div class="mainBlock" data-hr-toggle="current" data-hr-class-on="currentLink">
                                    {{name}}
                                </div>
                            </a>
                        </li>
                    </template>
                    <template data-hr-variant="root">
                        <div class="children" data-hr-model="children" data-hr-model-component="sidebarMenuComponent" data-hr-toggle="children" data-hr-class-on="expanded" data-hr-style-off="display:none;"></div>
                    </template>
                </ul>
            </div>
        </div>

        <!-- Page Content -->
        <div id="content">
            <div class="container-fluid">
                <div class="row">
                    <div class="col-md-12 pageContent">
                        <h1>Client Generation</h1>
<p>In addition to generating forms automatically it is also possible to generate clients to access your app&#39;s api automatically. Currently there are client generators for both Typescript, C# and PHP.</p>
<p>Generated clients will define an Injector class for each entry point in your system. They will define a Result class for each view model. Each rel that your view model defines will expose several functions in the Result class. There will be one named after the <strong>rel</strong> itself, which will actually call the endpoint. You will get one called <strong>canRel</strong>, which will return true or false depending on if the rel is accessible. You will get a <strong>getRelDocs</strong> function to get the definition of the rel from the server and a <strong>hasRelDocs</strong> function to check to see if there is a docs link to lookup. Finally you will get a <strong>linkForRel</strong> function that will return the rel&#39;s link directly if you need it for some reason.&nbsp;Additionally you will get a <strong>data</strong> accessor function that provides you the actual data in the result. Finally all of your model classes and any enums or additional classes you have defined will be generated into this file as well so you can use strongly typed versions of them when you are working on code.</p>
<p>Client generation is one of the built in tools for your application. You can run them by running your application with the arguments <code>tools &quot;clientgen OutputFile&quot;</code> where OutputFile is the location you want to save the results with either a .ts (for typescript), .cs (for c#) or .php (for php) extension.</p>
<h2>Typescript</h2>
<p>The generated typescript clients are the front end classes for the&nbsp;<strong>htmlrapier.halcyon</strong> library. With this you can use that library to access your apis without needing to remember all the rels on the client side yourself. Just make sure that library is included in package.json, which is done by default in the template. You can generate a typescript client 2 ways. The first is using the UpdateClient debug mode in Visual Studio. This will run the project and update its Client\Libs\ServiceClient.ts file automatically. Otherwise you can run the app with the arguments <code>tools &quot;clientgen OutputFileLocation.ts&quot;</code> to output a typescript file in the location of your choosing. Most of the time you will just use the UpdateClient mode in visual studio to do this.</p>
<p>One other thing to consider with the generated typescript code is that you can change your data on the server without regenerating a client, however, if you rename a rel then you must generate a new client or the old one will never be able to call the renamed endpoints. All of the actual result data is defined as a typescript interface, which does not actually exist at runtime in typescript and everything is just javascript objects. Its usually a good idea to regenerate clients as you change your code, but you don&#39;t have to.</p>
<h2>C#</h2>
<p>The generated c# clients are the front end classes for the <strong>Threax.AspNetCore.Halcyon.Client</strong> library. This works mostly like the typescript version, however, it is more important to keep this up to date as the data changes on the api side. This is because the data is deserialized into actual c# objects, which must define all of their properties, so this version is less flexible than the typescript version when it comes to updates. To generate a c# client run the program with the arguments&nbsp;<code>tools &quot;clientgen OutputFileLocation.cs&quot;</code> to generate the c# file in the location of your choosing.</p>
<p>There is more information about setting up a library for c# clients on the <a href="/HypermediaDocs/service-client-template">Service Client Template</a> page.</p>
<h2>PHP</h2>
<p>The generated php clients are the front end classes for the HalcyonPhpClient library. To generate a php library run <code>tools &quot;clientgen OutputFileLocation.php&quot;</code>. To use this client in your php app see <a href="http://~/php/connecting-php-apps-to-net-core-apps">this page</a>.</p>
                        <div class="footer"></div>
                    </div>
                </div>
                <div class="footer-padding"></div>
            </div>
        </div>
    </div>
    <script type="text/javascript" src="/HypermediaDocs/lib/tslib.js?linkver=20210601023522"></script>
<script type="text/javascript" src="/HypermediaDocs/lib/jquery/dist/jquery.min.js?linkver=20210601023522"></script>
<script type="text/javascript" src="/HypermediaDocs/lib/popper.js/dist/popper.min.js?linkver=20210601023522"></script>
<script type="text/javascript" src="/HypermediaDocs/lib/bootstrap/dist/js/bootstrap.min.js?linkver=20210601023522"></script>
<script type="text/javascript" src="/HypermediaDocs/lib/tsbin.prod.js?linkver=20210601023522"></script>
<script type="text/javascript" src="/HypermediaDocs/lib/hr-run.js?linkver=20210601023522"></script>

</body>

</html>